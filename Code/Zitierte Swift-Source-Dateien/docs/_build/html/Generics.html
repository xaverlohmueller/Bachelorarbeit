<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generics in Swift &mdash; Swift 3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/swift.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="Swift 3.0 documentation" href="contents.html" />
    <link rel="next" title="Logical Objects" href="LogicalObjects.html" />
    <link rel="prev" title="Error Handling Rationale and Proposal" href="ErrorHandlingRationale.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Swift 3.0 documentation</span></a></h1>
        <h2 class="heading"><span>Generics in Swift</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="contents.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="LogicalObjects.html">Logical Objects</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="generics-in-swift">
<span id="generics"></span><h1>Generics in Swift<a class="headerlink" href="#generics-in-swift" title="Permalink to this headline">¶</a></h1>
<div class="section" id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>Most types and functions in code are expressed in terms of a single, concrete
set of sets. Generics generalize this notion by allowing one to express types
and functions in terms of an abstraction over a (typically unbounded) set of
types, allowing improved code reuse. A typical example of a generic type is a
linked list of values, which can be used with any type of value. In C++, this
might be expressed as:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="kd">class </span><span class="nc">List</span><span class="w"> </span><span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="w">  </span><span class="kd">struct </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>where List&lt;Int&gt;, List&lt;String&gt;, and List&lt;DataRecord&gt; are all distinct types that
provide a linked list storing integers, strings, and DataRecords,
respectively. Given such a data structure, one also needs to be able to
implement generic functions that can operate on a list of any kind of elements,
such as a simple, linear search algorithm:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">typename</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">find</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">for </span><span class="p">(</span><span class="n">typename</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Node</span><span class="w"> </span><span class="o">*</span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
<span class="w">    </span><span class="kr">if </span><span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">      </span><span class="kr">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>

<span class="w">  </span><span class="kr">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Generics are important for the construction of useful libraries, because they
allow the library to adapt to application-specific data types without losing
type safety. This is especially important for foundational libraries containing
common data structures and algorithms, since these libraries are used across
nearly every interesting application.</p>
<p>The alternatives to generics tend to lead to poor solutions:</p>
<ul class="simple">
<li>Object-oriented languages tend to use &#8220;top&#8221; types (id in Objective-C,
java.lang.Object in pre-generics Java, etc.) for their containers and
algorithms, which gives up static type safety. Pre-generics Java forced the
user to introduce run-time-checked type casts when interacting with containers
(which is overly verbose), while Objective-C relies on id&#8217;s unsound implicit
conversion behavior to eliminate the need for casts.</li>
<li>Many languages bake common data structures (arrays, dictionaries, tables) into
the language itself. This is unfortunate both because it significantly
increases the size of the core language and because users then tend to use
this limited set of data structures for <em>every</em> problem, even when another
(not-baked-in) data structure would be better.</li>
</ul>
<p>Swift is intended to be a small, expressive language with great support for
building libraries. We&#8217;ll need generics to be able to build those libraries
well.</p>
</div>
<div class="section" id="goals">
<h2>Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Generics should enable the development of rich generic libraries that feel
similar to first-class language features</li>
<li>Generics should work on any type, whether it is a value type or some kind of
object type</li>
<li>Generic code should be almost as easy to write as non-generic code</li>
<li>Generic code should be compiled such that it can be executed with any data
type without requiring a separate &#8220;instantiation&#8221; step</li>
<li>Generics should interoperate cleanly with run-time polymorphism</li>
<li>Types should be able to retroactively modified to meet the requirements of a
generic algorithm or data structure</li>
</ul>
<p>As important as the goals of a feature are the explicit non-goals, which we
don&#8217;t want or don&#8217;t need to support:</p>
<ul class="simple">
<li>Compile-time &#8220;metaprogramming&#8221; in any form</li>
<li>Expression-template tricks a la Boost.Spirit, POOMA</li>
</ul>
</div>
<div class="section" id="polymorphism">
<h2>Polymorphism<a class="headerlink" href="#polymorphism" title="Permalink to this headline">¶</a></h2>
<p>Polymorphism allows one to use different data types with a uniform
interface. Overloading already allows a form of polymorphism (ad hoc
polymorphism) in Swift. For example, given:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>func +(x : Int, y : Int) -&gt; Int { add... }
func +(x : String, y : String) -&gt; String { concat... }
</pre></div>
</div>
<p>we can write the expression &#8220;x + y&#8221;, which will work for both integers and
strings.</p>
<p>However, we want the ability to express an algorithm or data structure
independently of mentioning any data type. To do so, we need a way to express
the essential interface that algorithm or data structure requires. For example,
an accumulation algorithm would need to express that for any type T, one can
write the expression &#8220;x + y&#8221; (where x and y are both of type T) and it will
produce another T.</p>
</div>
<div class="section" id="protocols">
<h2>Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></h2>
<p>Most languages that provide some form of polymorphism also have a way to
describe abstract interfaces that cover a range of types: Java and C#
interfaces, C++ abstract base classes, Objective-C protocols, Scala traits,
Haskell type classes, C++ concepts (briefly), and many more.  All allow one to
describe functions or methods that are part of the interface, and provide some
way to re-use or extend a previous interface by adding to it. We&#8217;ll start with
that core feature, and build onto it what we need.</p>
<p>In Swift, I suggest that we use the term protocol for this feature, because I
expect the end result to be similar enough to Objective-C protocols that our
users will benefit, and (more importantly) different enough from Java/C#
interfaces and C++ abstract base classes that those terms will be harmful. The
term trait comes with the wrong connotation for C++ programmers, and none of our
users know Scala.</p>
<p>In its most basic form, a protocol is a collection of function signatures:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">protocol </span><span class="nc">Document</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">title</span><span class="p">()</span><span class="o"> -&gt; </span><span class="no">String</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Document describes types that have a title() operation that accepts no arguments
and returns a String. Note that there is implicitly a &#8216;self&#8217; type,
which is the type that conforms to the protocol itself. This follows how most
object-oriented languages describe interfaces, but deviates from Haskell type
classes and C++ concepts, which require explicit type parameters for all of the
types. We&#8217;ll revisit this decision later.</p>
</div>
<div class="section" id="protocol-inheritance">
<h2>Protocol Inheritance<a class="headerlink" href="#protocol-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Composition of protocols is important to help programmers organize and
understand a large number of protocols and the data types that conform to those
protocols. For example, we could extend our Document protocol to cover documents
that support versioning:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">protocol </span><span class="nc">VersionedDocument</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Document</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">version</span><span class="p">()</span><span class="o"> -&gt; </span><span class="no">Int</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Multiple inheritance is permitted, allowing us to form a directed acyclic graph
of protocols:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>protocol PersistentDocument : VersionedDocument, Serializable {
  func saveToFile(_ filename : path)
}
</pre></div>
</div>
<p>Any type that conforms to PersistentDocument also conforms to VersionedDocument,
Document, and Serializable, which gives us substitutability.</p>
</div>
<div class="section" id="self-types">
<h2>Self Types<a class="headerlink" href="#self-types" title="Permalink to this headline">¶</a></h2>
<p>Protocols thus far do not give us an easy way to express simple binary
operations. For example, let&#8217;s try to write a Comparable protocol that could be
used to search for a generic find() operation:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">protocol </span><span class="nc">Comparable</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">isEqual</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">???</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Bool</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our options for filling in ??? are currently very poor. We could use the syntax
for saying &#8220;any type&#8221; or &#8220;any type that is comparable&#8221;, as one must do most OO
languages, including Java, C#, and Objective-C, but that&#8217;s not expressing what
we want: that the type of both of the arguments be the same. This is sometimes
referred to as the binary method problem
(<a class="reference external" href="http://www.cis.upenn.edu/~bcpierce/papers/binary.ps">http://www.cis.upenn.edu/~bcpierce/papers/binary.ps</a> has a discussion of this
problem, including the solution I&#8217;m proposing below).</p>
<p>Neither C++ concepts nor Haskell type classes have this particular problem,
because they don&#8217;t have the notion of an implicit &#8216;Self&#8217; type. Rather,
they explicitly parameterize everything. In C++ concepts:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">concept</span><span class="w"> </span><span class="n">Comparable</span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">bool</span><span class="w"> </span><span class="n">T</span><span class="p">::</span><span class="n">isEqual</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Java and C# programmers work around this issue by parameterizing the
interface, e.g. (in Java):</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">abstract</span><span class="w"> </span><span class="kd">class </span><span class="nc">Comparable</span><span class="p">&lt;</span><span class="no">THIS</span><span class="w"> </span><span class="n">extends</span><span class="w"> </span><span class="no">Comparable</span><span class="p">&lt;</span><span class="no">THIS</span><span class="p">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">public</span><span class="w"> </span><span class="n">bool</span><span class="w"> </span><span class="n">isEqual</span><span class="p">(</span><span class="n">THIS</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and then a class X that wants to be Comparable will inherit from
Comparable&lt;X&gt;. This is ugly and has a number of pitfalls; see
<a class="reference external" href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6479372">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6479372</a>.</p>
<p>Scala and Strongtalk have the notion of the &#8216;Self&#8217; type, which effectively
allows one to refer to the eventual type of &#8216;self&#8217; (which we call
&#8216;self&#8217;). &#8216;Self&#8217; (which we call &#8216;Self&#8217; in Swift) allows us to express the
Comparable protocol in a natural way:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">protocol </span><span class="nc">Comparable</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">isEqual</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Self</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Bool</span>
<span class="p">}</span>
</pre></div>
</div>
<p>By expressing Comparable in this way, we know that if we have two objects of
type T where T conforms to Comparable, comparison between those two objects with
isEqual is well-typed. However, if we have objects of different types T and U,
we cannot compare those objects with isEqual even if both T and U are
Comparable.</p>
<p>Self types are not without their costs, particularly in the case where Self is
used as a parameter type of a class method that will be subclassed. Here, the
parameter type ends up being (implicitly) covariant, which tightens up
type-checking but may also force us into more dynamic type checks. We can
explore this separately; within protocols, type-checking for Self is more
direct.</p>
</div>
<div class="section" id="associated-types">
<h2>Associated Types<a class="headerlink" href="#associated-types" title="Permalink to this headline">¶</a></h2>
<p>In addition to Self, a protocol&#8217;s operations often need to refer to types that
are related to the type of &#8216;Self&#8217;, such as a type of data stored in a
collection, or the node and edge types of a graph. For example, this would allow
us to cleanly describe a protocol for collections:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">protocol </span><span class="nc">Collection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">typealias</span><span class="w"> </span><span class="n">Element</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">forEach</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Element</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Void</span><span class="p">)</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">add</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Element</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is important here that a generic function that refers to a given type T,
which is known to be a collection, can access the associated types corresponding
to T. For example, one could implement an &#8220;accumulate&#8221; operation for an
arbitrary Collection, but doing so requires us to specify some constraints on
the Value type of the collection. We&#8217;ll return to this later.</p>
</div>
<div class="section" id="operators-properties-and-subscripting">
<h2>Operators, Properties, and Subscripting<a class="headerlink" href="#operators-properties-and-subscripting" title="Permalink to this headline">¶</a></h2>
<p>As previously noted, protocols can contain both function requirements (which are
in effect requirements for instance methods) and associated type
requirements. Protocols can also contain operators, properties, and subscript
operators:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>protocol RandomAccessContainer : Collection {
  var count: Int
  func == (lhs: Self, rhs: Self)
  subscript(i: Int) -&gt; Element
}
</pre></div>
</div>
<p>Operator requirements can be satisfied by operator definitions, property
requirements can be satisfied by either variables or properties, and subscript
requirements can be satisfied by subscript operators.</p>
</div>
<div class="section" id="conforming-to-a-protocol">
<h2>Conforming to a Protocol<a class="headerlink" href="#conforming-to-a-protocol" title="Permalink to this headline">¶</a></h2>
<p>Thus far, we have not actually shown how a type can meet the requirements of a
protocol. The most syntactically lightweight approach is to allow implicit
conformance. This is essentially duck typing, where a type is assumed to conform
to a protocol if it meets the syntactic requirements of the protocol. For
example, given:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">protocol </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">draw</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One could write a Circle struct such as:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">struct </span><span class="nc">Circle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">center</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">radius</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Int</span>

<span class="w">  </span><span class="kd">func </span><span class="nf">draw</span><span class="p">() {</span>
<span class="w">    </span><span class="c1">// draw it</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Circle provides a draw() method with the same input and result types as required
by the Shape protocol. Therefore, Circle conforms to Shape.</p>
<p>Implicit protocol conformance is convenient, because it requires no additional
typing. However, it can run into some trouble when an entity that syntactically
matches a protocol doesn&#8217;t provide the required semantics. For example, Cowboys
also know how to &#8220;draw!&#8221;:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">struct </span><span class="nc">Cowboy</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">gun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">SixShooter</span>

<span class="w">  </span><span class="kd">func </span><span class="nf">draw</span><span class="p">() {</span>
<span class="w">    </span><span class="c1">// draw!</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is unlikely that Cowboy is meant to conform to Shape, but the method name and
signatures match, so implicit conformance deduces that Cowboy conforms to
Shape. Random collisions between types are fairly rare. However, when one is
using protocol inheritance with fine-grained (semantic or mostly-semantic)
differences between protocols in the hierarchy, they become more common. See
<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1798.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1798.html</a> for examples
of this problem as it surfaced with C++ concepts. It is not clear at this time
whether we want implicit conformance in Swift: there&#8217;s no existing code to worry
about, and explicit conformance (described below) provides some benefits.</p>
</div>
<div class="section" id="explicit-protocol-conformance">
<h2>Explicit Protocol Conformance<a class="headerlink" href="#explicit-protocol-conformance" title="Permalink to this headline">¶</a></h2>
<p>Type authors often implement types that are intended to conform to a particular
protocol. For example, if we want a linked-list type to conform to Collection,
we can specify that it is by adding a protocol conformance annotation to the
type:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">struct </span><span class="nc">EmployeeList</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Collection</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// EmployeeList is a collection</span>
<span class="w">  </span><span class="n">typealias</span><span class="w"> </span><span class="n">Element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">forEach</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Element</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Void</span><span class="p">) {</span><span class="w"> </span><span class="cm">/* Implement this */</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">add</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Element</span><span class="p">) {</span><span class="w"> </span><span class="cm">/* Implement this */</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This explicit protocol conformance declaration forces the compiler to check that
EmployeeList actually does meet the requirements of the Collection protocol. If
we were missing an operation (say, forEach) or had the wrong signature, the
definition of &#8216;EmployeeList&#8217; would be ill-formed. Therefore, explicit
conformance provides both documentation for the user of EmployeeList and
checking for the author and future maintainers of EmployeeList.</p>
<p>Any nominal type (such as an enum, struct, or class) can be specified to conform
to one or more protocols in this manner. Additionally, a typealias can be
specified to conform to one or more protocols, e.g.,:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">typealias</span><span class="w"> </span><span class="n">NSInteger</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Numeric</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Int</span>
</pre></div>
</div>
<p>While not technically necessary due to retroactive modeling (below), this can be
used to document and check that a particular type alias does in fact meet some
basic, important requirements. Moreover, it falls out of the syntax that places
requirements on associated types.</p>
</div>
<div class="section" id="retroactive-modeling">
<h2>Retroactive Modeling<a class="headerlink" href="#retroactive-modeling" title="Permalink to this headline">¶</a></h2>
<p>When using a set of libraries, it&#8217;s fairly common that one library defines a
protocol (and useful generic entities requiring that protocol) while another
library provides a data type that provides similar functionality to that
protocol, but under a different name.  Retroactive modeling is the process by
which the type is retrofitted (without changing the type) to meet the
requirements of the protocol.</p>
<p>In Swift, we provide support for retroactive modeling by allowing
extensions, e.g.,:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">extension </span><span class="nc">String</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Collection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">typealias</span><span class="w"> </span><span class="n">Element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">char</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">forEach</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">callback</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Element</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Void</span><span class="p">) {</span><span class="w"> </span><span class="cm">/* use existing String routines to enumerate characters */</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">add</span><span class="p">(</span><span class="n">_</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Element</span><span class="p">) {</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="cm">/* append character */</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once an extension is defined, the extension now conforms to the Collection
protocol, and can be used anywhere a Collection is expected.</p>
</div>
<div class="section" id="default-implementations">
<h2>Default Implementations<a class="headerlink" href="#default-implementations" title="Permalink to this headline">¶</a></h2>
<p>The functions declared within a protocol are requirements that any type must
meet if it wants to conform to the protocol. There is a natural tension here,
then, between larger protocols that make it easier to write generic algorithms,
and smaller protocols that make it easier to write conforming types. For
example, should a Numeric protocol implement all operations, e.g.,:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>protocol Numeric {
  func +(lhs : Self, rhs : Self) -&gt; Self
  func -(lhs : Self, rhs : Self) -&gt; Self
  func +(x : Self) -&gt; Self
  func -(x : Self) -&gt; Self
}
</pre></div>
</div>
<p>which would make it easy to write general numeric algorithms, but requires the
author of some BigInt class to implement a lot of functionality, or should the
numeric protocol implement just the core operations:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>protocol Numeric {
  func +(lhs : Self, rhs : Self) -&gt; Self
  func -(x : Self) -&gt; Self
}
</pre></div>
</div>
<p>to make it easier to adopt the protocol (but harder to write numeric
algorithms)? Both of the protocols express the same thing (semantically),
because one can use the core operations (binary +, unary -) to implement the
other algorithms. However, it&#8217;s far easier to allow the protocol itself to
provide default implementations:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>protocol Numeric {
  func +(lhs : Self, rhs : Self) -&gt; Self
  func -(lhs : Self, rhs : Self) -&gt; Self { return lhs + -rhs }
  func +(x : Self) -&gt; Self { return x }
  func -(x : Self) -&gt; Self
}
</pre></div>
</div>
<p>This makes it easier both to implement generic algorithms (which can use the
most natural syntax) and to make a new type conform to the protocol. For
example, if we were to define only the core algorithms in our BigNum type:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>struct BigNum : Numeric {
  func +(lhs : BigNum, rhs : BigNum) -&gt; BigNum { ... }
  func -(x : BigNum) -&gt; BigNum { ... }
}
</pre></div>
</div>
<p>the compiler will automatically synthesize the other operations needed for the
protocol. Moreover, these operations will be available to uses of the BigNum
class as if they had been written in the type itself (or in an extension of the
type, if that feature is used), which means that protocol conformance actually
makes it easier to define types that conform to protocols, rather than just
providing additional checking.</p>
</div>
<div class="section" id="subtype-polymorphism">
<h2>Subtype Polymorphism<a class="headerlink" href="#subtype-polymorphism" title="Permalink to this headline">¶</a></h2>
<p>Subtype polymorphism is based on the notion of substitutability. If a type S is
a subtype of a type T, then a value of type S can safely be used where a value
of type T is expected. Object-oriented languages typically use subtype
polymorphism, where the subtype relationship is based on inheritance: if the
class Dog inherits from the class Animal, then Dog is a subtype of
Animal. Subtype polymorphism is generally dynamic, in the sense that the
substitution occurs at run-time, even if it is statically type-checked.</p>
<p>In Swift, we consider protocols to be types. A value of protocol type has an
existential type, meaning that we don&#8217;t know the concrete type until run-time
(and even then it varies), but we know that the type conforms to the given
protocol. Thus, a variable can be declared with type &#8220;Serializable&#8221;, e.g.,:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">var </span><span class="nv">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Serializable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">// value of any Serializable type</span>
<span class="n">x</span><span class="p">.</span><span class="n">serialize</span><span class="p">()</span><span class="w"> </span><span class="c1">// okay: serialize() is part of the Serializable protocol</span>
</pre></div>
</div>
<p>Naturally, such polymorphism is dynamic, and will require boxing of value types
to implement. We can now see how Self types interact with subtype
polymorphism. For example, say we have two values of type Comparable, and we try
to compare them:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">var </span><span class="nv">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">..</span><span class="p">.</span>
<span class="kd">var </span><span class="nv">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">..</span><span class="p">.</span>
<span class="kr">if </span><span class="n">x</span><span class="p">.</span><span class="n">isEqual</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// well-typed?</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Whether x.isEqual(y) is well-typed is not statically determinable, because the
dynamic type of x may different from the dynamic type of y, even if they are
both comparable (e.g., one is an Int and the other a String). It can be
implemented by the compiler as a dynamic type check, with some general failure
mode (aborting, throwing an exception, etc.) if the dynamic type check fails.</p>
<p>To express types that meet the requirements of several protocols, one can just
create a new protocol aggregating those protocols:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>protocol SerializableDocument : Document, Serializable { }
var doc : SerializableDocument
print(doc.title()) // okay: title() is part of the Document protocol, so we can call it
doc.serialize(stout) // okay: serialize() is part of the Serializable protocol
</pre></div>
</div>
<p>However, this only makes sense when the resulting protocol is a useful
abstraction. A SerializableDocument may or may not be a useful abstraction. When
it is not useful, one can instead use protocol&lt;&gt; types to compose different
protocols, e.g.,:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">var </span><span class="nv">doc</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">protocol</span><span class="o">&lt;</span><span class="n">Document</span><span class="p">,</span><span class="w"> </span><span class="n">Serializable</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Here, doc has an existential type that is known to conform to both the Document
and Serializable protocols. This gives rise to a natural &#8220;top&#8221; type, such that
every type in the language is a subtype of &#8220;top&#8221;. Java has java.lang.Object, C#
has object, Objective-C has &#8220;id&#8221; (although &#8220;id&#8221; is weird, because it is also
convertible to everything; it&#8217;s best not to use it as a model). In Swift, the
&#8220;top&#8221; type is simply an empty protocol composition:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">typealias</span><span class="w"> </span><span class="n">Any</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">protocol</span><span class="o">&lt;&gt;</span>

<span class="kd">var </span><span class="nv">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Any</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="w"> </span><span class="c1">// an any can hold an integer</span>
<span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="c1">// or a String</span>
<span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Red</span><span class="p">)</span><span class="w"> </span><span class="c1">// or anything else</span>
</pre></div>
</div>
</div>
<div class="section" id="bounded-parametric-polymorphism">
<h2>Bounded Parametric Polymorphism<a class="headerlink" href="#bounded-parametric-polymorphism" title="Permalink to this headline">¶</a></h2>
<p>Parametric polymorphism is based on the idea of providing type parameters for a
generic function or type. When using that function or type, one substitutes
concrete types for the type parameters. Strictly speaking, parametric
polymorphism allows <em>any</em> type to be substituted for a type parameter, but it&#8217;s
useless in practice because that means that generic functions or types cannot do
anything to the type parameters: they must instead rely on first-class functions
passed into the generic function or type to perform any meaningful work.</p>
<p>Far more useful (and prevalent) is bounded parametric polymorphism, which allows
the generic function or type to specify constraints (bounds) on the type
parameters. By specifying these bounds, it becomes far easier to write and use
these generic functions and types.  Haskell type classes, Java and C# generics,
C++ concepts, and many other language features support bounded parametric
polymorphism.</p>
<p>Protocols provide a natural way to express the constraints of a generic function
in Swift. For example, one could define a generic linked list as:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">struct </span><span class="nc">ListNode</span><span class="p">&lt;</span><span class="no">T</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">Value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">T</span>
<span class="w">  </span><span class="n">enum</span><span class="w"> </span><span class="n">NextNode</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">case</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">End</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">Next</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">NextNode</span>
<span class="p">}</span>

<span class="kd">struct </span><span class="nc">List</span><span class="p">&lt;</span><span class="no">T</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">First</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">NextNode</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This list works on any type T. One could then add a generic function that
inserts at the beginning of the list:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">func </span><span class="nf">insertAtBeginning</span><span class="p">&lt;</span><span class="no">T</span><span class="p">&gt;(</span><span class="n">_</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">, </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">T</span><span class="p">) {</span>
<span class="w">  </span><span class="n">list</span><span class="p">.</span><span class="n">First</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">First</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="expressing-constraints">
<h2>Expressing Constraints<a class="headerlink" href="#expressing-constraints" title="Permalink to this headline">¶</a></h2>
<p>Within the type parameter list of a generic type or function (e.g., the &lt;T&gt; in
ListNode&lt;T&gt;), the &#8216;T&#8217; introduces a new type parameter and the (optional) &#8221;:
type&#8221; names a protocol (or protocol composition) to which &#8216;T&#8217; must
conform. Within the body of the generic type or function, any of the functions
or types described by the constraints are available. For example, let&#8217;s
implement a find() operation on lists:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">func </span><span class="nf">find</span><span class="p">&lt;</span><span class="no">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="p">&gt;(</span><span class="n">_</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">, </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">T</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Int</span><span class="p"> {</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">current</span><span class="w"></span>
<span class="w">  </span><span class="kr">for </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">First</span><span class="p">;</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">Node</span><span class="p">;</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">Next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kr">if </span><span class="n">current</span><span class="p">.</span><span class="no">Value</span><span class="p">.</span><span class="n">isEqual</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// okay: T is Comparable</span>
<span class="w">      </span><span class="kr">return</span><span class="w"> </span><span class="n">index</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kr">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition to providing constraints on the type parameters, we also need to be
able to constrain associated types. To do so, we introduce the notion of a
&#8220;where&#8221; clause, which follows the signature of the generic type or
function. For example, let&#8217;s generalize our find algorithm to work on any
ordered collection:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>protocol OrderedCollection : Collection {
  func size() -&gt; Int
  func getAt(_ index : Int) -&gt; Element // Element is an associated type
}

func find&lt;C : OrderedCollection where C.Element : Comparable&gt;(
       _ collection : C, value : C.Element) -&gt; Int
{
  for index in 0...collection.size() {
    if (collection.getAt(index) == value) { // okay: we know that C.Element is Comparable
      return index
    }
  }
  return -1
}
</pre></div>
</div>
<p>The where clause is actually the more general way of expressing constraints,
and the constraints expressed in the angle brackets (e.g., &lt;C :
OrderedCollection&gt;) are just sugar for a where clause.  For example, the
above find() signature is equivalent to:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">func </span><span class="nf">find</span><span class="p">&lt;</span><span class="no">C</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="no">C</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">OrderedCollection</span><span class="p">,</span><span class="w"> </span><span class="no">C</span><span class="p">.</span><span class="no">Element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="p">&gt;(</span>
<span class="w">       </span><span class="n">_</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="p">, </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Int</span>
</pre></div>
</div>
<p>Note that find&lt;C&gt; is shorthand for (and equivalent to) find&lt;C : Any&gt;, since
every type conforms to the Any protocol composition.</p>
<p>There are two other important kinds of constraints that need to be
expressible. Before we get to those, consider a simple &#8220;Enumerator&#8221; protocol that
lets us describe an iteration of values of some given value type:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">protocol </span><span class="nc">Enumerator</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">typealias</span><span class="w"> </span><span class="n">Element</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">isEmpty</span><span class="p">()</span><span class="o"> -&gt; </span><span class="no">Bool</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">next</span><span class="p">()</span><span class="o"> -&gt; </span><span class="no">Element</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, we want to express the notion of an enumerable collection, which provides
iteration, which we do by adding requirements into the protocol:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">protocol </span><span class="nc">EnumerableCollection</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Collection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">typealias</span><span class="w"> </span><span class="n">EnumeratorType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Enumerator</span>
<span class="w">  </span><span class="n">where</span><span class="w"> </span><span class="n">EnumeratorType</span><span class="p">.</span><span class="n">Element</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Element</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">getEnumeratorType</span><span class="p">()</span><span class="o"> -&gt; </span><span class="no">EnumeratorType</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, we are specifying constraints on an associated type (EnumeratorType must
conform to the Enumerator protocol), by adding a conformance clause (: Enumerator)
to the associated type definition. We also use a separate where clause to
require that the type of values produced by querying the enumerator is the same as
the type of values stored in the container. This is important, for example, for
use with the Comparable protocol (and any protocol using Self types), because it
maintains type identity within the generic function or type.</p>
</div>
<div class="section" id="constraint-inference">
<h2>Constraint Inference<a class="headerlink" href="#constraint-inference" title="Permalink to this headline">¶</a></h2>
<p>Generic types often constrain their type parameters. For example, a
SortedDictionary, which provides dictionary functionality using some kind of
balanced binary tree (as in C++&#8217;s std::map), would require that its key type be
Comparable:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">class </span><span class="nc">SortedDictionary</span><span class="p">&lt;</span><span class="no">Key</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="p">,</span><span class="w"> </span><span class="no">Value</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Naturally, one any generic operation on a SortedDictionary&lt;K,V&gt; would also require
that K be Comparable, e.g.,:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">func </span><span class="nf">forEachKey</span><span class="p">&lt;</span><span class="no">Key</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="p">,</span><span class="w"> </span><span class="no">Value</span><span class="p">&gt;(</span><span class="n">_</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">SortedDictionary</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">, </span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">Key</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Void</span><span class="p">) {</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>However, explicitly requiring that Key conform to Comparable is redundant: one
could not provide an argument for &#8216;c&#8217; without the Key type of the
SortedDictionary conforming to Comparable, because the SortedDictionary type
itself could not be formed. Constraint inference infers these additional
constraints within a generic function from the parameter and return types of the
function, simplifying the specification of forEachKey:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">func </span><span class="nf">forEachKey</span><span class="p">&lt;</span><span class="no">Key</span><span class="p">,</span><span class="w"> </span><span class="no">Value</span><span class="p">&gt;(</span><span class="n">_</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">SortedDictionary</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">, </span><span class="n">Value</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">                            </span><span class="n">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">Key</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Void</span><span class="p">) {</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-parameter-deduction">
<h2>Type Parameter Deduction<a class="headerlink" href="#type-parameter-deduction" title="Permalink to this headline">¶</a></h2>
<p>As noted above, type arguments will be deduced from the call arguments to a
generic function:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">var </span><span class="nv">values</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">list</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span>
<span class="n">insertAtBeginning</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">)</span><span class="w"> </span><span class="c1">// deduces T = Int</span>
</pre></div>
</div>
<p>Since Swift already has top-down type inference (as well as the C++-like
bottom-up inference), we can also deduce type arguments from the result type:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>func cast&lt;T, U&gt;(_ value : T) -&gt; U { ... }
var x : Any
var y : Int = cast(x) // deduces T = Any, U = Int
</pre></div>
</div>
<p>We require that all type parameters for a generic function be deducible. We
introduce this restriction so that we can avoid introducing a syntax for
explicitly specifying type arguments to a generic function, e.g.,:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">var </span><span class="nv">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="c1">// not permitted: &lt; is the less-than operator</span>
</pre></div>
</div>
<p>This syntax is horribly ambiguous in C++, and with good type argument deduction,
should not be necessary in Swift.</p>
</div>
<div class="section" id="implementation-model">
<h2>Implementation Model<a class="headerlink" href="#implementation-model" title="Permalink to this headline">¶</a></h2>
<p>Because generics are constrained, a well-typed generic function or type can be
translated into object code that uses dynamic dispatch to perform each of its
operations on type parameters. This is in stark contrast to the instantiation
model of C++ templates, where each new set of template arguments requires the
generic function or type to be compiled again. This model is important for
scalability of builds, so that the time to perform type-checking and code
generation scales with the amount of code written rather than the amount of code
instantiated. Moreover, it can lead to smaller binaries and a more flexible
language (generic functions can be &#8220;virtual&#8221;).</p>
<p>The translation model is fairly simple. Consider the generic find() we
implemented for lists, above:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">func </span><span class="nf">find</span><span class="p">&lt;</span><span class="no">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="p">&gt;(</span><span class="n">_</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">, </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">T</span><span class="p">)</span><span class="o"> -&gt; </span><span class="no">Int</span><span class="p"> {</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="kd">var </span><span class="nv">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">First</span>
<span class="w">  </span><span class="n">while</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">ListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// now I&#39;m just making stuff up</span>
<span class="w">    </span><span class="kr">if </span><span class="n">current</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">isEqual</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// okay: T is Comparable</span>
<span class="w">      </span><span class="kr">return</span><span class="w"> </span><span class="n">index</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">Next</span>
<span class="w">    </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kr">return</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</div>
<p>to translate this into executable code, we form a vtable for each of the
constraints on the generic function. In this case, we&#8217;ll have a vtable for
Comparable T. Every operation within the body of this generic function
type-checks to either an operation on some concrete type (e.g., the operations
on Int), to an operation within a protocol (which requires indirection through
the corresponding vtable), or to an operation on a generic type definition, all
of which can be emitted as object code.</p>
</div>
<div class="section" id="specialization">
<span id="generics-specialization"></span><h2>Specialization<a class="headerlink" href="#specialization" title="Permalink to this headline">¶</a></h2>
<p>This implementation model lends itself to optimization when we know the specific
argument types that will be used when invoking the generic function. In this
case, some or all of the vtables provided for the constraints will effectively
be constants. By specializing the generic function (at compile-time, link-time,
or (if we have a JIT) run-time) for these types, we can eliminate the cost of
the virtual dispatch, inline calls when appropriate, and eliminate the overhead
of the generic system. Such optimizations can be performed based on heuristics,
user direction, or profile-guided optimization.</p>
<p>An internal &#64;_specialize function attribute allows developers to force
full specialization by listing concrete type names corresponding to the
function&#8217;s generic signature. A function&#8217;s generic signature is a
concatenation of its generic context and the function&#8217;s own generic
type parameters.:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>struct S&lt;T&gt; {
  var x: T
  @_specialize(Int, Float)
  mutating func exchangeSecond&lt;U&gt;(_ u: U, _ t: T) -&gt; (U, T) {
    x = t
    return (u, x)
  }
}

// Substitutes: &lt;T, U&gt; with &lt;Int, Float&gt; producing:
// S&lt;Int&gt;::exchangeSecond&lt;Float&gt;(u: Float, t: Int) -&gt; (Float, Int)
</pre></div>
</div>
<p>&#64;_specialize currently acts as a hint to the optimizer, which
generates type checks and code to dispatch to the specialized routine
without affecting the signature of the generic function. The
intention is to support efforts at evaluating the performance of
specialized code. The performance impact is not guaranteed and is
likely to change with the optimizer. This attribute should only be
used in conjunction with rigorous performance analysis. Eventually,
a similar attribute could be defined in the language, allowing it to be
exposed as part of a function&#8217;s API. That would allow direct dispatch
to specialized code without type checks, even across modules.</p>
</div>
<div class="section" id="existential-types-and-generics">
<h2>Existential Types and Generics<a class="headerlink" href="#existential-types-and-generics" title="Permalink to this headline">¶</a></h2>
<p>Both existential types and generics depend on dynamic dispatching based on
protocols. A value of an existential type (say, Comparable) is a pair (value,
vtable). &#8216;value&#8217; stores the current value either directly (if it fits in the 3
words allocated to the value) or as a pointer to the boxed representation (if
the actual representation is larger than 3 words). By itself, this value cannot
be interpreted, because it&#8217;s type is not known statically, and may change due to
assignment. The vtable provides the means to manipulate the value, because it
provides a mapping between the protocols to which the existential type conforms
(which is known statically) to the functions that implementation that
functionality for the type of the value. The value, therefore, can only be
safely manipulated through the functions in this vtable.</p>
<p>A value of some generic type T uses a similar implementation model.  However,
the (value, vtable) pair is split apart: values of type T contain only the value
part (the 3 words of data), while the vtable is maintained as a separate value
that can be shared among all T&#8217;s within that generic function.</p>
</div>
<div class="section" id="overloading">
<h2>Overloading<a class="headerlink" href="#overloading" title="Permalink to this headline">¶</a></h2>
<p>Generic functions can be overloaded based entirely on constraints. For example,
consider a binary search algorithm:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">func </span><span class="nf">binarySearch</span><span class="p">&lt;</span><span class="w"></span>
<span class="w">   </span><span class="no">C</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">EnumerableCollection</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="no">C</span><span class="p">.</span><span class="no">Element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="w"></span>
<span class="p">&gt;(</span><span class="n">_</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="p">, </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">EnumeratorType</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// We can perform log(N) comparisons, but EnumerableCollection</span>
<span class="w">  </span><span class="c1">// only supports linear walks, so this is linear time</span>
<span class="p">}</span>

<span class="kd">protocol </span><span class="nc">RandomAccessEnumerator</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Enumerator</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// splits a range in half, returning both halves</span>
<span class="w">  </span><span class="kd">func </span><span class="nf">split</span><span class="p">()</span><span class="o"> -&gt; </span><span class="p">(</span><span class="no">Enumerator</span><span class="p">,</span><span class="w"> </span><span class="no">Enumerator</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func </span><span class="nf">binarySearch</span><span class="p">&lt;</span><span class="w"></span>
<span class="w">   </span><span class="no">C</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">EnumerableCollection</span><span class="w"></span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="no">C</span><span class="p">.</span><span class="no">Element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Comparable</span><span class="p">,</span><span class="w"></span>
<span class="w">              </span><span class="no">C</span><span class="p">.</span><span class="no">EnumeratorType</span><span class="p">:</span><span class="w"> </span><span class="no">RandomAccessEnumerator</span><span class="w"></span>
<span class="p">&gt;(</span><span class="n">_</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="p">, </span><span class="n">value</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">C</span><span class="p">.</span><span class="n">Element</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span><span class="p">.</span><span class="n">EnumeratorType</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// We can perform log(N) comparisons and log(N) range splits,</span>
<span class="w">  </span><span class="c1">// so this is logarithmic time</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If binarySearch is called with a sequence whose range type conforms to
RandomAccessEnumerator, both of the generic functions match. However, the second
function is more specialized, because its constraints are a superset of the
constraints of the first function. In such a case, overloading should pick the
more specialized function.</p>
<p>There is a question as to when this overloading occurs. For example,
binarySearch might be called as a subroutine of another generic function with
minimal requirements:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span>func doSomethingWithSearch&lt;
  C : EnumerableCollection where C.Element : Ordered
&gt;(
  _ collection : C, value : C.Element
) -&gt; C.EnumeratorType
{
  binarySearch(collection, value)
}
</pre></div>
</div>
<p>At the time when the generic definition of doSomethingWithSearch is
type-checked, only the first binarySearch() function applies, since we don&#8217;t
know that C.EnumeratorType conforms to RandomAccessEnumerator. However, when
doSomethingWithSearch is actually invoked, C.EnumeratorType might conform to the
RandomAccessEnumerator, in which case we&#8217;d be better off picking the second
binarySearch. This amounts to run-time overload resolution, which may be
desirable, but also has downsides, such as the potential for run-time failures
due to ambiguities and the cost of performing such an expensive operation at
these call sites. Of course, that cost could be mitigated in hot generic
functions via the specialization mentioned above.</p>
<p>Our current proposal for this is to decide statically which function is called
(based on similar partial-ordering rules as used in C++), and avoid run-time
overload resolution. If this proves onerous, we can revisit the decision later.</p>
</div>
<div class="section" id="parsing-issues">
<h2>Parsing Issues<a class="headerlink" href="#parsing-issues" title="Permalink to this headline">¶</a></h2>
<p>The use of angle brackets to supply arguments to a generic type, while familiar
to C++/C#/Java programmers, cause some parsing problems. The problem stems from
the fact that &#8216;&lt;&#8217;, &#8216;&gt;&#8217;, and &#8216;&gt;&gt;&#8217; (the latter of which will show up in generic
types such as Array&lt;Array&lt;Int&gt;&gt;) match the &#8216;operator&#8217; terminal in the grammar,
and we wish to continue using this as operators.</p>
<p>When we&#8217;re in the type grammar, this is a minor inconvenience for the parser,
because code like this:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">var </span><span class="nv">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Array</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>will essentially parse the type as:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">identifier</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">identifier</span><span class="w"> </span><span class="n">operator</span>
</pre></div>
</div>
<p>and verify that the operators are &#8216;&lt;&#8217; and &#8216;&gt;&#8217;, respectively. Cases
involving &lt;&gt; are more interesting, because the type of:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="kd">var </span><span class="nv">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Array</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>is effectively parsed as:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">identifier</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">identifier</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">identifier</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">operator</span>
</pre></div>
</div>
<p>by splitting the &#8216;&gt;&gt;&#8217; operator token into two &#8216;&gt;&#8217; operator tokens.</p>
<p>However, this is manageable, and is already implemented for protocol composition
(protocol&lt;&gt;). The larger problem occurs at expression context, where the parser
cannot disambiguate the tokens:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>i.e.,:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">identifier</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">identifier</span><span class="w"> </span><span class="n">operator</span><span class="w"> </span><span class="n">unspaced_lparen</span><span class="w"> </span><span class="n">integer</span><span class="o">-</span><span class="n">literal</span><span class="w"> </span><span class="n">comma</span><span class="w"> </span><span class="n">integer</span><span class="o">-</span><span class="n">literal</span><span class="w"> </span><span class="n">rparen</span>
</pre></div>
</div>
<p>which can be interpreted as either:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">greater_than</span>
<span class="w">  </span><span class="p">(</span><span class="n">less_than</span>
<span class="w">    </span><span class="p">(</span><span class="n">declref</span><span class="w"> </span><span class="n">Matrix</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">declref</span><span class="w"> </span><span class="n">Double</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="n">tuple</span>
<span class="w">    </span><span class="p">(</span><span class="n">integer_literal</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">integer_literal</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">constructor</span><span class="w"> </span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">(</span><span class="n">tuple</span>
<span class="w">    </span><span class="p">(</span><span class="n">integer_literal</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="n">integer_literal</span><span class="w"> </span><span class="mi">10</span><span class="p">)))</span>
</pre></div>
</div>
<p>Both Java and C# have this ambiguity. C# resolves the ambiguity by looking at
the token after the closing &#8216;&gt;&#8217; to decide which way to go; Java seems to do the
same. We have a few options:</p>
<ol class="arabic simple">
<li>Follow C# and Java and implement the infinite lookahead needed to make this
work. Note that we have true ambiguities, because one could make either of
the above parse trees well-formed.</li>
<li>Introduce some kind of special rule for &#8216;&lt;&#8217; like we have for &#8216;(&#8216;, such as: an
identifier followed by an unspaced &#8216;&lt;&#8217; is a type, while an identifier
followed by spacing and then &#8216;&lt;&#8217; is an expression, or</li>
<li>Pick some syntax other than angle brackets, which is not ambiguous.  Note
that neither &#8216;(&#8216; nor &#8216;[&#8216; work, because they too have expression forms.</li>
<li>Disambiguate between the two parses semantically.</li>
</ol>
<p>We&#8217;re going to try a variant of #1, using a variation of the disambiguation
rule used in C#. Essentially, when we see:</p>
<div class="highlight-swift"><div class="highlight"><pre><span></span><span class="n">identifier</span><span class="w"> </span><span class="o">&lt;</span>
</pre></div>
</div>
<p>we look ahead, trying to parse a type parameter list, until parsing the type
parameter list fails or we find a closing &#8216;&gt;&#8217;. We then look ahead an additional
token to see if the closing &#8216;&gt;&#8217; is followed by a &#8216;(&#8216;, &#8216;.&#8217;, or closing bracketing
token (since types are most commonly followed by a constructor call or static
member access). If parsing the type parameter list succeeds, and the closing
angle bracket is followed by a &#8216;(&#8216;, &#8216;.&#8217;, or closing bracket token, then the
&#8216;&lt;...&gt;&#8217; sequence is parsed as a generic parameter list; otherwise, the &#8216;&lt;&#8217;
is parsed as an operator.</p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="contents.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="LogicalObjects.html">Logical Objects</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Apple Inc.
      Last updated on 2016-04-29.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.4.
    </div>
  </body>
</html>